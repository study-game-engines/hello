#version 430

struct Complex {
  float r;
  float i;
};

struct VertexPN {
  float x, y, z;
  float nx, ny, nz;
};

layout (std430, binding = 0) readonly restrict buffer BufferH {
  Complex h[];
};

layout (std430, binding = 1) readonly restrict buffer BufferDispX {
  Complex dispX[];
};

layout (std430, binding = 2) readonly restrict buffer BufferDispZ {
  Complex dispZ[];
};

layout (std430, binding = 3) writeonly restrict buffer BufferMesh {
  VertexPN mesh[];
};

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout(r32f, binding = 0) uniform image2D outputImage;

uniform uvec2 u_oceanSize;
uniform uvec2 u_meshSize; 
uniform float u_dispFactor;

void main() {
    uvec2 gid = gl_GlobalInvocationID.xy;

    // Bail if out of bounds
    if (gid.x >= u_meshSize.x || gid.y >= u_meshSize.y) {
        return;
    }

    uint vertIndex = gid.y * u_meshSize.x + gid.x;

    ivec2 offset = ivec2(gid) - ivec2(u_meshSize) / 2;

    uint ox = uint((offset.x % int(u_oceanSize.x) + int(u_oceanSize.x)) % int(u_oceanSize.x));
    uint oz = uint((offset.y % int(u_oceanSize.y) + int(u_oceanSize.y)) % int(u_oceanSize.y));
    uint oceanIndex = oz * u_oceanSize.x + ox;

    float sign = ((offset.x + offset.y) & 1) != 0 ? 1.0 : -1.0;

    float height = sign * h[oceanIndex].r;
    float deltaX = u_dispFactor * sign * dispX[oceanIndex].r;
    float deltaZ = u_dispFactor * sign * dispZ[oceanIndex].r;

    float x = float(offset.x) + deltaX;
    float z = float(offset.y) + deltaZ;

    uint meshIndex = gid.y * u_meshSize.x + gid.x;

    mesh[meshIndex].x = x + (u_oceanSize.x * 0.5);
    mesh[meshIndex].y = height;
    mesh[meshIndex].z = z + (u_oceanSize.x * 0.5);

    if (gid.x < u_oceanSize.x || gid.y < u_oceanSize.y) {
	    ivec2 pixelCoords = ivec2(gl_GlobalInvocationID.xy);
        imageStore(outputImage, pixelCoords, vec4(height, 0, 0, 0));
    }
}